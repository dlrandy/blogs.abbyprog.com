---
templateKey: blog-post
id:solid-design-principles
title: solid design principles
slug: /2021/01/09/solid-create-design-pattern/
date: 2021-01-09T03:48:03.125Z
description: 学习solid design patterns
headerImage: https://i.imgur.com/Ivxkc3R.jpg
tags:
  - js, solid, design pattern, create
---

设计模式是反复发生的问题的可复用方案

create design pattern 主要是解决创建对象相关的问题。

> 工厂模式将对象的创建封装在函数里；revealing constructor 只在对象创建的时候，暴露私有对象的属性和方法；Builder 模式简化了复杂对象的创建的过程；单例和依赖注入有助于写 module。

**js 里建议使用通用的直觉的图示而不是 uml 来描述 pattern，因为一些模式不但可以基于 class，还会基于对象或者函数**

### Factory

主要是将对象的创建从特殊的实现中解耦出来。

#### 应用场景

1. 创建对象的类是在运行时确定的（增加一些额外的初始化步骤或者基于条件返回不同的克星）
2. 相比类，工厂是一个函数，暴露出的信息更少，更易理解
3. 通过闭包强化封装

> js 中，函数范式优先于 OO 设计模式，函数范式更为简单，可用和 small surface area.

#### 使用 new 创建对象有什么不好？

new 关键字会将 code 和特定的对象类型进行绑定。而工厂则会提供更多的灵活性。

#### 强化封装

封装指的是控制组件内部的一些细节的访问，通过阻止外部 code 直接处理组件的内部细节。外部只能通过组件的公共接口处理组件的细节。
**面向对象的重要设计原则：继承 抽象 封装 多态**

##### 封装的方式

1. 使用私有 class fileds, #fieldname
2. 使用 weakmap 隐藏细节信息，一般使用 this 作为键值
3. 使用 symbol，但是可以通过 Reflect.ownKeys 和 Object.getOwnPropertySymbols 获取到私有键值
4. 使用约定'\_'
5. 使用工厂或者闭包
6. 构造器里使用 var,const,let 以及函数的声明都是私有的

### Builder

通过提供流畅的接口(易读，自文档化)，简化复杂对象的创建，一步一步的构建对象，创建过程更清晰。改善了可读性和开发者体验。

#### 适用场景

1. 类的参数比较多的情况，或者是参数比较复杂
   > 对参数较多的时候，一般会使用对象容纳参数，但是不好的地方在于要想了解实际的参数，就只能去看 class 的文档或者是 class 的 code。同时也没有相干类的创建协议。

#### 实现 builder 模式的常用规则

1.  主要目的是将复杂的构造器拆分成多个更可读的更可管理的步骤
2.  尝试去创建 builder 的方法，这些方法可以设置都多个相关的参数
3.  通过 setter 方法减少和隐式设置参数
4.  必要的话，可以在将参数传递到构造器之前进一步处理参数

### 揭示构造函数
```javascript
const object = new SomeClass(function executor(revealedMemers){


})
```
#### 应用情况
1. 创建的对象只在创建的时候才能修改
2. 创建的对象的自定义行为只在创建的时候定义
3. 创建的对象只在创建的时候初始化一次

> 这个模式的揭露函数是不能要对象的使用者在对象创建之后访问到，一般可以使用工厂模式。








### 单例模式

单例模式只是为了强化一个类实例的出现，集中化了它的访问。

#### 使用单例的原因

1. 共享状态信息
2. 优化资源的使用率
3. 同步资源的访问

### 依赖注入

单例和模块虽然简单好用，但那是会有组件耦合的问题--组件不能没有某个依赖，不能根据情况切换成其他同类依赖。
**模块是根据它的完整路径缓存的**
**创建一个第三方使用的 package，尽量使得这个包无状态**

#### 依赖注入解决的问题
将外部实体作为输入提供给组件作为依赖。

注入器初始化不同的组件，然后将组件的依赖衔接在一起。它可以是简单的初始化脚本或者是复杂的全局container映射所有的依赖和衔接系统所有模块的互连。

> 使用DI，每个依赖不是硬编码在模块里的，而是从外面获取的。意味着依赖模块可以被配置成使用任何的兼容依赖，而模块本身更容易复用。

#### 依赖注入的方式
1. 构造器注入
2. 函数注入
3. 属性注入

依赖注入虽然解耦，但是影响可读性。它是要开发人员在写code时候，要手动解析依赖，手动的构建整个app的依赖图

### 控制反转
因为依赖注入需要手动写模块，那么可以通过IOC将写模块的职责转移到第三方实体。这个实体可以是service locator(获取依赖的组件)或者是dependency injection container(基于元数据或者配置文件将依赖注入到组件的系统)
